<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1411182105024">{:repl-history {:ide [], :local [&quot;(mapcat #(keys  (:coeff %)) eqns)&quot; &quot;(into #{} (mapcat #(keys  (:coeff %)) eqns))&quot; &quot;(sort (into #{} (mapcat #(keys  (:coeff %)) eqns)))&quot; &quot;(defn get-vars [equations]\n  (sort (into #{} (mapcat #(keys  (:coeff %)) eqns))))&quot; &quot;(get-vars eqns)&quot; &quot;(get-coeff [equation var]\n           (get-in equation [:coeff var]))&quot; &quot;(defn get-coeff [equation var]\n  (get-in equation [:coeff var]))&quot; &quot;(get-coeff cost :XONE)&quot; &quot;(defn columns [equations]\n  (let [vars (get-vars equations)]\n    (for var vars eqn equations)\n    (get-coeff eqn var)))&quot; &quot;(defn columns [equations]\n  (let [vars (get-vars equations)]\n    (for [var vars eqn equations])\n    (get-coeff eqn var)))&quot; &quot;(defn columns [equations]\n  (let [vars (get-vars equations)]\n    (for [var vars])\n      var\n    ))&quot; &quot;columns (eqns)&quot; &quot;(defn columns [equations]\n  (let [vars (get-vars equations)]\n    (for [var vars eqn equations]\n      [eqn var])))&quot; &quot;(c)&quot; &quot;(defn columns [equations]\n  (let [vars (get-vars equations)]\n    (for [var vars eqn equations]\n      (get-coeff eqn var))))&quot; &quot;(defn columns [equations]\n  (let [vars (get-vars equations)]\n    (for [var vars eqn equations]\n      {:var var :eqn (:name eqn) :coeff (get-coeff eqn var)} )))&quot; &quot;(defn columns [equations]\n  (filter\n    #(not (nil? (:coeff %)))\n    (let [vars (get-vars equations)]\n      (for [var vars eqn equations]\n        {:var var :eqn (:name eqn) :coeff (get-coeff eqn var)} ))))&quot; &quot;(print-column [m]\n              (str \&quot;    \&quot; (:var m) \&quot; \&quot; (:eqn m) \&quot; \&quot; (:coeff)))&quot; &quot;(defn get-columns [equations]\n  (filter\n    #(not (nil? (:coeff %)))\n    (let [vars (get-vars equations)]\n      (for [var vars eqn equations]\n        {:var var :eqn (:name eqn) :coeff (get-coeff eqn var)} ))))&quot; &quot;(defn print-column [m]\n  (str \&quot;    \&quot; (:var m) \&quot; \&quot; (:eqn m) \&quot; \&quot; (:coeff)))&quot; &quot;(print-column )&quot; &quot;(defn columns [equations]\n  (let [cols (get-columns equations)]\n    (str \&quot;COLUMNS\\n\&quot;\n         (clojure.string/join (map print-column cols)))))&quot; &quot;(defn print-column [m]\n  (str \&quot;    \&quot; (:var m) \&quot; \&quot; (:eqn m) \&quot; \&quot; (:coeff m)))&quot; &quot;(columns eqns)&quot; &quot;(filter #(not (nil? ())) (map #(into {} (:name %) (:rhs %)))    equations)&quot; &quot;(filter #(not (nil? ())) (map #(into {} (:name %) (:rhs %)))    eqns)&quot; &quot;(map #(into {} (:name %) (:rhs %))    eqns)&quot; &quot;(into {} (:rhs cost))&quot; &quot;(into {} (:rhs cost) (:name cost))&quot; &quot;{(:rhs cost) (:name cost)}&quot; &quot;(map #({(:name %) (:rhs %)})    equations)&quot; &quot;(map #({(:name %) (:rhs %)})    eqns)&quot; &quot;(take 10 \&quot;                \&quot;)&quot; &quot;(str (take 10 \&quot;                \&quot;))&quot; &quot;(clojure.string/join \&quot;\&quot; (take 10 \&quot;                \&quot;))&quot; &quot;(clojure.string/join \&quot;\&quot; (take 10 \&quot;NAME                \&quot;))&quot; &quot;(repeat \&quot;e\&quot; 4)&quot; &quot;(repeat 4 \&quot;e\&quot;)&quot; &quot;(take 4 \&quot;    \&quot;)&quot; &quot;(defn space-it[text width]\n  (take width (str text (clojure.string/join (repeat width \&quot; \&quot;)))))&quot; &quot;(space-it \&quot;NAME\&quot; 15)&quot; &quot;\n(defn space-it[text width]\n  (clojure.string/join (take width (str text (clojure.string/join (repeat width \&quot; \&quot;))))))&quot; &quot;(space-it \&quot;NAME\&quot; 14)&quot; &quot;(defn header [name]\n  (str (space-it \&quot;NAME\&quot; 14) name))&quot; &quot;(header \&quot;TEST\&quot;)&quot; &quot;(defn footer []\n   \&quot;ENDATA\&quot;)&quot; &quot;(defn make-file [equations]\n   (str (footer)))&quot; &quot;(make-file eqns)&quot; &quot;(defn make-file [name equations]\n   (str \n     (header name)\n     (footer)))&quot; &quot;()&quot; &quot;(defn make-file [name equations]\n   (str\n     (header name)\n     (rows equations)\n     (footer)))&quot; &quot;(make-file \&quot;TEST\&quot; eqns)&quot; &quot;\&quot;\\newlinex\&quot;&quot; &quot;(printf (make-file \&quot;TEST\&quot; eqns))&quot; &quot;(defn test []\n   (printf (\&quot;TEST\&quot;) eqns))&quot; &quot;(defn test-it []\n   (printf (\&quot;TEST\&quot;) eqns))&quot; &quot;(defn test-it []\n   (printf (make-file \&quot;TEST\&quot; eqns)))&quot; &quot;(defn make-file [name equations]\n   (str\n     (header name)\n     (columns equations)\n     (rows equations)\n     (footer)))&quot; &quot;(defn print-column [m]\n  (str \&quot;    \&quot; (space-it (:var m) 11) (space-it (:eqn m) 10) \&quot; \&quot; (:coeff m)) \&quot;\\n\&quot;)&quot; &quot;(defn print-column [m]\n  (str (space-it \&quot;\&quot; 4) (space-it (:var m) 11) (space-it (:eqn m) 10) \&quot; \&quot; (:coeff m)\&quot;\\n\&quot;))&quot; &quot;(defn get-columns [equations]\n  (filter\n    #(not (nil? (:coeff %)))\n  (let [vars (get-vars equations)]\n    (for [var vars eqn equations]\n        {:var (name var) :eqn (:name eqn) :coeff (get-coeff eqn var)} ))))&quot; &quot;(defn print-column [m]\n  (str (space-it \&quot;\&quot; 4) (space-it (:var m) 10) (space-it (:eqn m) 10) \&quot; \&quot; (:coeff m)\&quot;\\n\&quot;))&quot; &quot;(defn rhs [equations]\n   (str \&quot;RHS\\n\&quot;\n      (filter #(not (nil? ())) (map #({(:name %) (:rhs %)}))    equations)))&quot; &quot;(defn rhs [equations]\n   (str \&quot;RHS\\n\&quot;\n      (filter #(not (nil? %)) (map #({(:name %) (:rhs %)}))    equations)))&quot; &quot;(defn rhs [equations]\n   (str \&quot;RHS\\n\&quot;\n      (filter  #(not (nil? %)) (map #({(:name %) (:rhs %)}) equations))))&quot; &quot;(map #({(:name %) (:rhs %)}) equations)&quot; &quot;(map #({(:name %) (:rhs %)}) eqns)&quot; &quot;( (fn {(:name %) (:rhs %)} ) (first eqns))&quot; &quot;( (fn [] {(:name %) (:rhs %)} ) (first eqns))&quot; &quot;( (fn [x] {(:name x) (:rhs x)} ) (first eqns))&quot; &quot;(map #( {(:name %) (:rhs %)} ) eqns)&quot; &quot;#(\&quot;\&quot;)&quot; &quot;(map (fn [x] {(:name x) (:rhs x)} ) eqns)&quot; &quot;(defn rhs [equations]\n   (str \&quot;RHS\\n\&quot;\n      (filter  #(not (nil? %)) (map (fn [e] {(:name e) (:rhs e)}) equations))))&quot; &quot;(defn rhs [equations]\n   (str \&quot;RHS\\n\&quot;\n        (clojure.string/join (filter #(not (nil? %)) (map (fn [e] {(:name e) (:rhs e)}) equations)))))&quot; &quot;(defn rhs [equations]\n   (str \&quot;RHS\\n\&quot;\n        (clojure.string/join (filter #(not (nil? (second %))) (map (fn [e] [(:name e) (:rhs e)]) equations)))))&quot; &quot;(defn get-rhs [equations]\n   (filter #(not (nil? (second %))) (map (fn [e] [(:name e) (:rhs e)]) equations)))&quot; &quot;(get-rhs eqns)&quot; &quot;(defn print-rhs [rhs]\n   (str (space-it \&quot;\&quot; 4) (space-it \&quot;RHS1\&quot; 10) (space-it (first rhs) 10 ) \&quot; \&quot; (second rhs)))&quot; &quot;(defn rhs [equations]\n   (str \&quot;RHS\\n\&quot;\n        (clojore.string/join (map print-rhs (get-rhs equations)))))&quot; &quot;(defn rhs [equations]\n   (str \&quot;RHS\\n\&quot;\n        (clojure.string/join (map print-rhs (get-rhs equations)))))&quot; &quot;(defn print-rhs [rhs]\n   (str (space-it \&quot;\&quot; 4) (space-it \&quot;RHS1\&quot; 10) (space-it (first rhs) 10 ) \&quot; \&quot; (second rhs) \&quot;\\n\&quot;))&quot; &quot;(printf (rhs eqns))&quot; &quot;(defn make-file [name equations]\n   (str\n     (header name)\n     (columns equations)\n     (rows equations)\n     (rhs equations)\n     (footer)))&quot; &quot;(test-it)&quot; &quot;(def ub1 {:type \&quot;UP\&quot; :variable :XONE :value 4 })&quot; &quot;(def lb2 {:type \&quot;LO\&quot; :variable :YTWO :value -1 })&quot; &quot;(def ub2 {:type \&quot;UP\&quot; :variable :YTWO :value 1})&quot; &quot;(def bounds (list ub1 lb2 ub2))&quot; &quot;(defn print-bound [bound]\n   (str \&quot; \&quot; (:type bound) (space-it \&quot; BND1\&quot; 10) (space-it (:variable bound) 10) (:value bound) \&quot;\\n\&quot;))&quot; &quot;(defn print-bound [bound]\n   (str \&quot; \&quot; (:type bound) (space-it \&quot; BND1\&quot; 10) (space-it (name (:variable bound)) 10) (:value bound) \&quot;\\n\&quot;))&quot; &quot;(print-bound (first bounds))&quot; &quot;(printf (bounds bounds))&quot; &quot;bounds&quot; &quot;(def bnds (list ub1 lb2 ub2))&quot; &quot;(defn bounds [bounds]\n   (str \&quot;BOUNDS\\n\&quot;\n        (clojure.string/join (map print-bound) bounds)))&quot; &quot;(defn bounds [bnds]\n   (str \&quot;BOUNDS\\n\&quot;\n        (clojure.string/join (map print-bound) bnds)))&quot; &quot;(print-bound (first bnd))&quot; &quot;(print-bound (first bnds))&quot; &quot;(defn bounds [bnds]\n   (str \&quot;BOUNDS\\n\&quot;\n        (clojure.string/join (map print-bound bnds))))&quot; &quot;(printf (bounds bnds))&quot;], :remote []}}</component>
</project>

